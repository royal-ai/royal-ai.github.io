<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>/2022/05/28/vim%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="vim-学习之路"><a href="#vim-学习之路" class="headerlink" title="vim 学习之路"></a>vim 学习之路</h1><h2 id="遇到的坑"><a href="#遇到的坑" class="headerlink" title="遇到的坑"></a>遇到的坑</h2><h3 id="MAC下载VIM失败"><a href="#MAC下载VIM失败" class="headerlink" title="MAC下载VIM失败"></a>MAC下载VIM失败</h3><p><a href="https://zhuanlan.zhihu.com/p/383707713">参考</a></p>
<h3 id="键值映射"><a href="#键值映射" class="headerlink" title="键值映射"></a>键值映射</h3><p>使用vim的时候感觉每次都去按esc键非常的麻烦，于是可以使用命令 imap jk <esc> 来做键值映射，其中要注意的坑是在配置文件中不要写上:set paste,否则会覆盖插入模式的键值映射。</esc></p>
<h2 id="最终vim配置文件"><a href="#最终vim配置文件" class="headerlink" title="最终vim配置文件"></a>最终vim配置文件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">set fileencodings=utf-8,ucs-bom,gb18030,gbk,gb2312,cp936                                     </span><br><span class="line">set termencoding=utf-8</span><br><span class="line">set encoding=utf-8</span><br><span class="line">syntax on</span><br><span class="line">set nu</span><br><span class="line"></span><br><span class="line">set cul</span><br><span class="line"></span><br><span class="line">set showmatch </span><br><span class="line"></span><br><span class="line">set tabstop=4</span><br><span class="line">set shiftwidth=4</span><br><span class="line">set autoindent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line">autocmd BufWritePost $MYVIMRC source $MYVIMRC</span><br><span class="line">let mapleader=&#x27;,&#x27;</span><br><span class="line">imap jk &lt;esc&gt;</span><br><span class="line"> </span><br><span class="line">set hlsearch   </span><br></pre></td></tr></table></figure>



<p>参考链接：</p>
<p><a href="https://cn.ifaj-congress.org/236207-my-vim-basic-imap-mappings-HPNMZS-article">键值映射失败</a></p>
<p><a href="http://yyq123.github.io/learn-vim/learn-vi-51-KeyMapping.html">VIM键值映射</a></p>
<p><a href="https://www.jianshu.com/p/923aec861af3">MACVIM 配置</a></p>
]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2022/05/28/APUE/</url>
    <content><![CDATA[<h1 id="APUE-学习笔记"><a href="#APUE-学习笔记" class="headerlink" title="APUE 学习笔记"></a>APUE 学习笔记</h1><h2 id="1，setjmp-和-longjmp"><a href="#1，setjmp-和-longjmp" class="headerlink" title="1，setjmp 和 longjmp"></a>1，setjmp 和 longjmp</h2><p>使用setJump和longJump 相当于使用非局部的goto，可以在栈上跳过若干的调用帧，返回到当前函数的调用路径的某个函数中。<br>在希望返回到的位置调用setjmp,然后调用longjmp函数返回到setjmp的位置。setjump第一次调用返回0，否则是从longjmp调用返回的数值。<br>在longjmp返回的过程中，全局变量，静态变量，volatile 变量不会改变，其他类型的变量可能会回滚。</p>
<h2 id="2，getrlimit-和-setrlimit函数"><a href="#2，getrlimit-和-setrlimit函数" class="headerlink" title="2，getrlimit 和 setrlimit函数"></a>2，getrlimit 和 setrlimit函数</h2><p>每个进程都有一组资源限制，可以使用getrlimit和setrlimit函数来查询和更改。</p>
<h2 id="chapter-8"><a href="#chapter-8" class="headerlink" title="chapter 8"></a>chapter 8</h2><h3 id="进程标识符"><a href="#进程标识符" class="headerlink" title="进程标识符"></a>进程标识符</h3><p>ID为0的进程通常是调度进程，也被称为交换进程swapper,是内核的一部分。<br>ID为1的进程是init进程，负责初始化系统，将其引导到一个状态<br>ID为2的进程是守护进程pagedaemon。负责支持虚拟存储系统的分页操作<br>1 pid_t getpid (void) 返回进程ID_<br>_2 pid_t getppid(void) 返回父进程ID<br>3 getuid(void) 返回进程的实际用户ID<br>4 geteuid(void) 返回进程的有效用户ID<br>5 getgid(void) 返回进程的实际组ID<br>6 getegid(void) 返回进程的有小组ID</p>
<h3 id="pid-t-fork-void"><a href="#pid-t-fork-void" class="headerlink" title="pid_t fork(void)"></a>pid_t fork(void)</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806404776-85ca1ebc-b2f8-4f03-a7dc-70dc395fa580.png#crop=0&crop=0&crop=1&crop=1&id=VXzYT&originHeight=52&originWidth=575&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>fork的一个特性是父进程的所有打开文件描述符都被复制到子进程中。父子进程的每个打开描述符共享一个文件表项。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806405242-a1844547-667f-458f-9509-51eaceb86a71.png#crop=0&crop=0&crop=1&crop=1&id=hNi1E&originHeight=634&originWidth=900&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806405838-5fd0776c-f5da-4d16-a21f-3e0828c05460.png#crop=0&crop=0&crop=1&crop=1&id=VlDK6&originHeight=839&originWidth=1020&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806406339-67886af3-a585-45c5-9ad4-8b26a3b2cf3d.png#crop=0&crop=0&crop=1&crop=1&id=yFNP4&originHeight=150&originWidth=1010&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>fork失败的两个主要原因：</p>
<ol>
<li>系统中有了太多的进程，该实际用户ID的进程总数超过了系统限制</li>
<li>该用户实际ID的进程总数超过了系统限制</li>
</ol>
<p>- </p>
<h3 id="vfork"><a href="#vfork" class="headerlink" title="vfork"></a>vfork</h3><p>函数定义与fork相同，但是vfork用于创建一个新的进程，目的是执行exec一个新的程序。<br>好处：</p>
<ol>
<li>不复制父进程的地址空间，在调用exec和exit之前在父进程的空间中运行，并且优先运行子进程，直到子进程运行exec或者exit。</li>
</ol>
<h3 id="exit"><a href="#exit" class="headerlink" title="exit"></a>exit</h3><p>exit函数会调用终止处理程序，并总是执行一个标准I&#x2F;O库的清理关闭：为所有打开流执行fclose，冲洗所有数据到文件。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806406801-452ab8c6-9869-4430-a001-4107da4fbc43.png#crop=0&crop=0&crop=1&crop=1&id=DkEzt&originHeight=711&originWidth=922&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="wait和waitpid函数"><a href="#wait和waitpid函数" class="headerlink" title="wait和waitpid函数"></a>wait和waitpid函数</h3><p>当一个进程正常或异常终止时，内核向该进程的父进程发送一个SIGCHLD信号。父进程的默认动作是忽略该信号。但其应该调用waitpid函数<img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806407293-8d418afe-0b37-47f7-b2b3-b76ecadba24b.png#crop=0&crop=0&crop=1&crop=1&id=UfIzR&originHeight=144&originWidth=1004&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806407760-b308ef00-7fac-4a57-ace4-f6125735bca3.png#crop=0&crop=0&crop=1&crop=1&id=Z8CKn&originHeight=186&originWidth=1020&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>wait等待任意一个进程退出。staloc获得进程的终止状态。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806408332-55dd4c26-65a9-499d-be7c-9c4d2aeeaa9a.png#crop=0&crop=0&crop=1&crop=1&id=AZdDk&originHeight=446&originWidth=1085&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806408890-6f1fc065-a461-4d30-85d5-f4d636c8f144.png#crop=0&crop=0&crop=1&crop=1&id=deLuR&originHeight=707&originWidth=1146&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806409326-a8b05036-b431-4b0c-877f-7037907b7d3f.png#crop=0&crop=0&crop=1&crop=1&id=dq1y4&originHeight=244&originWidth=1130&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>waitpid 提供作业控制<br>&#x3D;&#x3D;注意&#x3D;&#x3D;:调用fork两次可以避免僵尸进程。</p>
<h3 id="exec"><a href="#exec" class="headerlink" title="exec"></a>exec</h3><p>子进程通常使用一种exec函数以执行另一个新的程序， exec用一个全新的程序替换了当前进程的正文，数据，堆和栈段。<br>有六种exec函数<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806409862-25b53db8-9138-4b8b-91b9-c3d53b07fa25.png#crop=0&crop=0&crop=1&crop=1&id=Xn7h2&originHeight=414&originWidth=1007&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>前四个取路径名作为参数，后两个以文件名作为参数。如果filename中包含&#x2F;，则将其视为路径名。否则就在PATH环境变量中查找。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806410379-2f6cd196-22e9-45e3-b4d4-b14965d1fb81.png#crop=0&crop=0&crop=1&crop=1&id=eE8Fx&originHeight=343&originWidth=926&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="更改用户ID和组ID"><a href="#更改用户ID和组ID" class="headerlink" title="更改用户ID和组ID"></a>更改用户ID和组ID</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806410583-24f544d5-8189-40c3-a638-b5bb87e2dce1.png#crop=0&crop=0&crop=1&crop=1&id=waGjx&originHeight=170&originWidth=1008&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806410930-86fb770d-0a6d-4f06-8072-5caf08d08e89.png#crop=0&crop=0&crop=1&crop=1&id=vr5Pk&originHeight=251&originWidth=1043&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806411405-012f5f17-49c5-4500-b79f-bd98c4bc8189.png#crop=0&crop=0&crop=1&crop=1&id=AEDdd&originHeight=327&originWidth=1031&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>注意理解设置用户位ID的作用。</p>
<h2 id="解析器文件"><a href="#解析器文件" class="headerlink" title="解析器文件"></a>解析器文件</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806411958-36b8b49c-5a15-41b1-a5ac-fa62fb7e8022.png#crop=0&crop=0&crop=1&crop=1&id=AdX6M&originHeight=99&originWidth=1023&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806412473-78db8858-3bda-4915-9503-20dd7a04fd0b.png#crop=0&crop=0&crop=1&crop=1&id=hncUr&originHeight=92&originWidth=1076&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="system-函数"><a href="#system-函数" class="headerlink" title="system 函数"></a>system 函数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806412693-7d3378d6-e1a6-4b71-bf58-36483fa45031.png#crop=0&crop=0&crop=1&crop=1&id=hGhKm&originHeight=102&originWidth=755&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806413237-f4829c02-6ea8-4977-9670-4db04e52f2bc.png#crop=0&crop=0&crop=1&crop=1&id=jnJyf&originHeight=190&originWidth=1071&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>使用system相当于新开了shell进程去执行shell命令，使用system，而不是直接使用fork和exec的优点是：system进行了所需的各种出错处理，以及信号处理。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806414145-6c9aff92-cb4b-4ea5-b75f-cc2fb07e0331.png#crop=0&crop=0&crop=1&crop=1&id=AvpIo&originHeight=129&originWidth=960&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="进程会计"><a href="#进程会计" class="headerlink" title="进程会计"></a>进程会计</h2><p>启动进程会计处理后，每当进程结束时，内核就会写一个会计记录，记录进程的命令名，cpu事件总量，用户ID和组ID。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806414617-01fcf912-1e9a-4408-a9e9-3d7f11c5f52a.png#crop=0&crop=0&crop=1&crop=1&id=WiQoC&originHeight=44&originWidth=571&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806415092-2f9a3c33-7edd-42a9-a541-cc7134f0866d.png#crop=0&crop=0&crop=1&crop=1&id=fCoMb&originHeight=78&originWidth=1000&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806415653-044ff766-fc3c-434b-9d09-3d1266f6816e.png#crop=0&crop=0&crop=1&crop=1&id=oYWAG&originHeight=601&originWidth=848&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="用户名函数"><a href="#用户名函数" class="headerlink" title="用户名函数"></a>用户名函数</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806416321-2ec83096-07a1-4332-9d7d-b409cc50ae25.png#crop=0&crop=0&crop=1&crop=1&id=VSBQh&originHeight=130&originWidth=944&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="进程时间"><a href="#进程时间" class="headerlink" title="进程时间"></a>进程时间</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806416657-49e40a69-d856-48aa-9b1f-6ad92a2a70f1.png#crop=0&crop=0&crop=1&crop=1&id=gziQj&originHeight=132&originWidth=986&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806417135-03a48b8d-9d35-497f-82fd-28a4d1101edd.png#crop=0&crop=0&crop=1&crop=1&id=GYGjI&originHeight=201&originWidth=880&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h1 id="chapter9"><a href="#chapter9" class="headerlink" title="chapter9"></a>chapter9</h1><h2 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806417410-d49d839a-63ce-4c7d-9a53-e20db309c4a0.png#crop=0&crop=0&crop=1&crop=1&id=XyqDL&originHeight=427&originWidth=951&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>init会为每个用户的进程fork这些程序。<br>其中login<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806417719-5ab268f3-b871-4aec-b5da-e0a97ee7f0e8.png#crop=0&crop=0&crop=1&crop=1&id=O1cKq&originHeight=54&originWidth=783&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>以下是login会干的事情<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806418236-41b763ea-2b60-4384-9e22-e56d765c9356.png#crop=0&crop=0&crop=1&crop=1&id=H4ix4&originHeight=338&originWidth=948&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>登录shell还将读取其启动文件，如.profile,.bash_profile,.bash_login等</p>
<h2 id="网络登录"><a href="#网络登录" class="headerlink" title="网络登录"></a>网络登录</h2><p>网络登录和系统登录的区别是：通过网络登录时，终端和计算机之间的连接不是点对点连接，在这种情况下，login 只是其中一种服务和其他网络服务如FTP,SMTP相同。<br>为了使一个软件可以处理不同的登录，系统使用了一种叫伪终端的驱动程序，(pseduo terminal)。关于什么inetd，好复杂。</p>
<h2 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h2><p>进程组是一个或多个进程的集合，通常它们与同一作业相关联，可以接受来自统一终端的信号。每个进程组都有一个进程ID.类型为pid_t<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806418746-ed43c30e-04af-49b3-b12c-6b0e40f93115.png#crop=0&crop=0&crop=1&crop=1&id=l2PMt&originHeight=143&originWidth=984&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806419218-4ac693e4-915b-4ce2-a494-b945d6aa3157.png#crop=0&crop=0&crop=1&crop=1&id=rSTe7&originHeight=116&originWidth=971&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>返回进程id为pid的进程的进程组id<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806419489-4bc59f93-0b24-4f73-9e93-be6b5faabc39.png#crop=0&crop=0&crop=1&crop=1&id=HZ8wX&originHeight=216&originWidth=1025&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="会话session"><a href="#会话session" class="headerlink" title="会话session"></a>会话session</h2><p>session是一个或多个进程组的集合。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806419819-b1b4a412-28b7-4b44-9d48-f330ec4ed900.png#crop=0&crop=0&crop=1&crop=1&id=TUwaA&originHeight=346&originWidth=943&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806420309-d2b6119a-9e7f-4196-9b6a-96a79759b839.png#crop=0&crop=0&crop=1&crop=1&id=IoJku&originHeight=131&originWidth=1030&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="控制终端"><a href="#控制终端" class="headerlink" title="控制终端"></a>控制终端</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806420845-ac41c1e7-5b0f-4e82-9060-ac6356c9a84f.png#crop=0&crop=0&crop=1&crop=1&id=kSmbD&originHeight=570&originWidth=1023&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="tcgetpgrp-tcsetpgrp-tcgetsid函数"><a href="#tcgetpgrp-tcsetpgrp-tcgetsid函数" class="headerlink" title="tcgetpgrp,tcsetpgrp,tcgetsid函数"></a>tcgetpgrp,tcsetpgrp,tcgetsid函数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806421464-2fc4ef62-6fc3-4a4a-b76c-8d7b12c7b6df.png#crop=0&crop=0&crop=1&crop=1&id=HaQ2t&originHeight=172&originWidth=1010&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>tcgetpgrp()返回前台进程组ID,该前台进程组与在filedes上打开的终端相关联。<br>tcsetpgrp将前台进程组ID设置为pgrpid。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806421995-4f8a6cf1-e42c-4a6f-a0ab-ed2635a5463e.png#crop=0&crop=0&crop=1&crop=1&id=G3mrr&originHeight=208&originWidth=980&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="孤儿进程组"><a href="#孤儿进程组" class="headerlink" title="孤儿进程组"></a>孤儿进程组</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806422543-4101795d-69be-4b86-9744-e3f597f127fa.png#crop=0&crop=0&crop=1&crop=1&id=X6Og9&originHeight=197&originWidth=1010&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h1 id="chapter10信号"><a href="#chapter10信号" class="headerlink" title="chapter10信号"></a>chapter10信号</h1><p>信号是软件中断，信号提供了一种处理异步事件的方法。</p>
<h2 id="信号概念"><a href="#信号概念" class="headerlink" title="信号概念"></a>信号概念</h2><p>信号是异步事件的经典实例。产生信号的事件对进程而言是随机出现的。该进程不能简单地测试一个变量来辨别是不是出现了一个信号。而是必须告诉内核“在此信号发生时，请执行下列操作”<br>可以要求信号按照下列的三种方式之一进行处理<br>1，忽略此信号。特例是有两种信号不能被忽略，SIGKILL和SIGSTOP.这两个信号向超级用户提供了使进程停止或终止的方法。<br>2，捕捉信号。执行用户设置的信号处理函数<br>3，执行系统默认动作</p>
<h2 id="signal"><a href="#signal" class="headerlink" title="signal"></a>signal</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806423032-49b536c1-5526-4b4b-892e-7f90856fe5b4.png#crop=0&crop=0&crop=1&crop=1&id=qsLfr&originHeight=152&originWidth=988&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>exec和fork对信号处理函数的影响：exec函数将原先设置为要捕捉的信号都更改为它们的默认动作，因为信号捕捉函数在所执行的新文件已无意义。<br>执行调用fork时，其子进程执行父进程的信号处理函数。</p>
<h2 id="不可靠的信号"><a href="#不可靠的信号" class="headerlink" title="不可靠的信号"></a>不可靠的信号</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806423518-18245f28-055d-442a-b8c9-c1f84183884e.png#crop=0&crop=0&crop=1&crop=1&id=RGCfl&originHeight=44&originWidth=913&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806423948-8c79c07a-0a8f-43f4-95ef-e7bcbe98b124.png#crop=0&crop=0&crop=1&crop=1&id=oA7MZ&originHeight=139&originWidth=980&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h1 id="中断的系统调用"><a href="#中断的系统调用" class="headerlink" title="中断的系统调用"></a>中断的系统调用</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806424222-82eafabd-a1ce-4a27-82e4-5d724e1dbe40.png#crop=0&crop=0&crop=1&crop=1&id=Fj1fj&originHeight=78&originWidth=988&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>重点：低速系统调用 slow system call：可能会使进程无限期等待的系统调用<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806424539-896de476-cc50-41f8-a5af-abd2b0e01ba6.png#crop=0&crop=0&crop=1&crop=1&id=O3RAc&originHeight=287&originWidth=997&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><a href="https://blog.csdn.net/benkaoya/article/details/17262053">如何处理被中断的系统调用</a><br>1，人为重启<br>2，安装信号时设置SA_RESTART属性（该方法对有的系统调用无效）<br>3，忽略信号</p>
<h2 id="可重入函数"><a href="#可重入函数" class="headerlink" title="可重入函数"></a>可重入函数</h2><p>可重入[编辑] 若一个程序或子程序可以「在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错」，则称其为&#x3D;&#x3D;可重入&#x3D;&#x3D;（reentrant或re-entrant）<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806425084-99fd718c-d45e-4ae5-9475-9fb93282e929.png#crop=0&crop=0&crop=1&crop=1&id=gLHLW&originHeight=737&originWidth=1044&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>若在信号处理程序中调用一个不可以重入的函数，其结果是不可预见的。</p>
<h2 id="kill-和-raise"><a href="#kill-和-raise" class="headerlink" title="kill 和 raise"></a>kill 和 raise</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806425553-d460347e-d6e6-4264-bec9-3fa8042eb0d8.png#crop=0&crop=0&crop=1&crop=1&id=nr5re&originHeight=49&originWidth=914&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806425792-b4387039-f9f2-48a3-9a1e-b08b0a6bb288.png#crop=0&crop=0&crop=1&crop=1&id=DujBM&originHeight=148&originWidth=490&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="pause和alarm"><a href="#pause和alarm" class="headerlink" title="pause和alarm"></a>pause和alarm</h2><p>pause 函数使调用进程挂起直至捕捉一个信号<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806426076-2b77d44c-6f74-49b7-a154-857a91463583.png#crop=0&crop=0&crop=1&crop=1&id=AkRnt&originHeight=126&originWidth=957&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806426285-e3d42c58-b6ee-4e5e-8590-6948def18fc7.png#crop=0&crop=0&crop=1&crop=1&id=Azr54&originHeight=130&originWidth=957&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>使用alarm和pause可以实现sleep的功能</p>
<h2 id="sigpending-函数"><a href="#sigpending-函数" class="headerlink" title="sigpending 函数"></a>sigpending 函数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806426626-399d01ad-9128-4322-9dc0-be83c62800cb.png#crop=0&crop=0&crop=1&crop=1&id=lOON6&originHeight=229&originWidth=1043&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="sigsuspend函数"><a href="#sigsuspend函数" class="headerlink" title="sigsuspend函数"></a>sigsuspend函数</h2><p>sigsuspend 将进程的信号屏蔽字设置为sigmask，并pause(),这两个操作结合成一个原子操作。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806427087-847dbbd2-7dda-4ddb-aa75-f8d0d1df2d56.png#crop=0&crop=0&crop=1&crop=1&id=CrmOv&originHeight=142&originWidth=991&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806427321-8759728a-fb2c-4d44-bbc5-9e3d19750a8b.png#crop=0&crop=0&crop=1&crop=1&id=zHced&originHeight=52&originWidth=722&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="abort-函数"><a href="#abort-函数" class="headerlink" title="abort 函数"></a>abort 函数</h2><p>abort函数的功能是使异常程序终止，此函数将SIGABRT信号发送给调用进程。<img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806427653-39427a6e-e4a3-45c2-b9cd-0683db449288.png#crop=0&crop=0&crop=1&crop=1&id=SL0Cw&originHeight=153&originWidth=956&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="sleep函数"><a href="#sleep函数" class="headerlink" title="sleep函数"></a>sleep函数</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806427885-880e2377-3f74-4fa8-affd-3fafc1e097f9.png#crop=0&crop=0&crop=1&crop=1&id=sglEn&originHeight=134&originWidth=956&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806428180-cdd48d3e-b5a1-43f4-97d0-58d71cc2d3ca.png#crop=0&crop=0&crop=1&crop=1&id=UMyC7&originHeight=101&originWidth=685&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="信号的转化函数-打印信号名"><a href="#信号的转化函数-打印信号名" class="headerlink" title="信号的转化函数(打印信号名)"></a>信号的转化函数(打印信号名)</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806428628-94e22b0f-e813-4238-ab9d-37a37138454a.png#crop=0&crop=0&crop=1&crop=1&id=NJgG4&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806429362-49bf6b7e-bce7-4d50-8674-c19ee7358c1a.png#crop=0&crop=0&crop=1&crop=1&id=SCzsX&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><h2 id="线程的好处"><a href="#线程的好处" class="headerlink" title="线程的好处"></a>线程的好处</h2><ul>
<li>通过为每种事件类型的处理分配单独的线程，能够简化处理异步事件的代码。每个线程在进行事件处理时可以采用同步编程模式。</li>
<li>多个线程可以自动地访问相同的存储地址空间和文件描述符</li>
<li>通过分解任务的形式改善整个环境的吞吐量</li>
<li>交互的程序同样可以通过使用多线程实现响应事件的改善，多线程可以把程序中用用户输入输出部分与其他部分分开来。</li>
</ul>
<p>每个线程独有的信息有执行环境必要的信息：<br>1，线程ID<br>2，一组寄存器<br>3，栈<br>4，调度优先级和策略<br>5，信号屏蔽字<br>6，errno变量<br>7，线程私有数据</p>
<h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p>线程ID和进程ID不同用pthread_t标识，使用函数来对线程ID进行比较。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806429827-8dca7ad2-e80b-4b5e-8f73-120d3e08e49c.png#crop=0&crop=0&crop=1&crop=1&id=nOrCO&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806430362-d4961d99-ba20-4c66-9343-b977ef8c11f6.png#crop=0&crop=0&crop=1&crop=1&id=pOzvy&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="线程的创建"><a href="#线程的创建" class="headerlink" title="线程的创建"></a>线程的创建</h2><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806430880-925b6e05-2083-4d66-b8ab-0f469b6120aa.png#crop=0&crop=0&crop=1&crop=1&id=uZSxb&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806431457-8e388c37-6d31-4da4-8682-1059d7b43dfc.png#crop=0&crop=0&crop=1&crop=1&id=RUEkN&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806431921-b0e745b8-b310-4e35-a30d-85bb06f2f856.png#crop=0&crop=0&crop=1&crop=1&id=kiSEo&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>linux的线程似乎使用进程来实现的。</p>
<h2 id="线程终止"><a href="#线程终止" class="headerlink" title="线程终止"></a>线程终止</h2><p>如果进程的某一线程调用了exit，_Exit或者 _exit，那么整个进程就会终止。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806432557-8d2e365e-40c2-421e-8cfa-96c2f4787ff5.png#crop=0&crop=0&crop=1&crop=1&id=ClupS&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806432975-3260d79a-7072-4688-b9fe-ac8f8c72a020.png#crop=0&crop=0&crop=1&crop=1&id=L4GMN&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>调用pthread_join的线程将一直阻塞，直到指定的线程调用pthread_exit，从启动例程中返回或者取消。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806433466-58277118-cea3-42e9-afd9-aadec4fc51da.png#crop=0&crop=0&crop=1&crop=1&id=fBPia&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h3><p>线程可以通过调用pthread_cancel函数来取消同一进程中的其他线程。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806433955-966a854e-08a9-4972-8251-fcae9d744001.png#crop=0&crop=0&crop=1&crop=1&id=mBLhO&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>pthread_cancel函数会使得由tid标识的线程的行为表现为如同调用了参数为PTHREAD_CANCELED的pthread_exit函数，但是线程可以选择忽略取消或是控制取消方式。<br>线程可以安排它退出时需要调用的函数。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806434419-2c844a82-baa4-4415-84b7-e551b160d613.png#crop=0&crop=0&crop=1&crop=1&id=mxFwv&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806434960-7443bd3d-6544-4d0e-9520-961bc5127fde.png#crop=0&crop=0&crop=1&crop=1&id=SpZ52&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806435542-56e56061-88f7-4de6-baab-258ee97ce4da.png#crop=0&crop=0&crop=1&crop=1&id=IqWkt&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806436033-73c789d1-2568-4784-938b-f5e7299b25fb.png#crop=0&crop=0&crop=1&crop=1&id=BQqKZ&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>线程可以处于分离状态，调用pthread_detach调用可以用于使线程进入分离状态。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806436252-4fb04345-7f66-453a-b011-8f377f6cf132.png#crop=0&crop=0&crop=1&crop=1&id=Ulbei&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806436577-53c6927e-73f6-4693-8cb2-4daa13291dff.png#crop=0&crop=0&crop=1&crop=1&id=q4RNO&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>简单来说就是处于分离状态的线程会在线程终止时自动回收状态，不需要也不应该被pthread_join等待。</p>
<h2 id="线程同步（互斥，读写锁和条件变量）"><a href="#线程同步（互斥，读写锁和条件变量）" class="headerlink" title="线程同步（互斥，读写锁和条件变量）"></a>线程同步（互斥，读写锁和条件变量）</h2><p>举个不同步的例子：i++增量操作可以分为三步：<br>（1）从内存单元读入寄存器<br>（2）在寄存器中进行变量值的增加<br>（3）把新的值写回内存单元<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806436981-9424a20a-836f-46e6-bca6-99a4f95326dc.png#crop=0&crop=0&crop=1&crop=1&id=cZWte&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>可以使用pthread的互斥接口保护数据，确保同一时间只有一个线程访问数据，可以通过对互斥量加锁和解锁来控制线程对数据的访问。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806437265-a388d4b7-bb5b-48d0-bc4f-c810fd387f1f.png#crop=0&crop=0&crop=1&crop=1&id=oiHAr&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>初始化和释放锁。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806437668-4a8d8ef0-406e-43ba-9d01-3b3c27403abc.png#crop=0&crop=0&crop=1&crop=1&id=icQGW&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h4 id="如何避免死锁？"><a href="#如何避免死锁？" class="headerlink" title="如何避免死锁？"></a>如何避免死锁？</h4><ol>
<li>控制加锁的顺序，假设需要对两个互斥量A和B同时加锁，如果所有线程总是在对互斥量B之前锁住互斥量A.那么就不会发生死锁</li>
<li>可以先释放锁，然后再试，这种情况可以使用pthread_mutex_trylock接口避免死锁。</li>
</ol>
<p>- </p>
<h3 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h3><p>读写锁允许更高的并行性，读写锁可以有三种状态：读模式下加锁，写模式加锁，不加锁。一次只有一个线程可以占有写模式的读写锁，但是多个线程可以同时占有读模式下的读写锁。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806438024-2ef7c1b0-8d45-44fd-96fb-23a4a6105da7.png#crop=0&crop=0&crop=1&crop=1&id=spxMS&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806438330-2808f51e-8ef4-40a0-8e59-92acaceb346d.png#crop=0&crop=0&crop=1&crop=1&id=vEIjn&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806438717-d6b2be91-609a-4b26-82c6-ef8c29d60129.png#crop=0&crop=0&crop=1&crop=1&id=cYCEq&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h3><p>条件变量是线程可用的另一种同步机制。条件变量给多个线程提供了一个回合的场所。条件变量与互斥量一起使用时，允许线程以无竞争的方式等待特定的条件发生。<br>条件变量本身是由互斥量保护的。线程在改变条件状态之前必须首先锁住互斥量，其他线程在获得互斥量之前不会察觉到这种改变。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806439065-819ab03f-8ced-451d-a34f-a99f6026264a.png#crop=0&crop=0&crop=1&crop=1&id=Gjpyl&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806439397-e0b0a748-f057-4646-94c0-5d1f743357ad.png#crop=0&crop=0&crop=1&crop=1&id=qMfsM&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806439776-c983f3df-5682-446b-bdcf-fdcc8405062c.png#crop=0&crop=0&crop=1&crop=1&id=EgbwS&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806440141-f2588525-ce32-45ea-84e7-583197fd2b94.png#crop=0&crop=0&crop=1&crop=1&id=r1T2Z&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806440462-99a6b22d-9e34-416a-abc1-3ec44152af9e.png#crop=0&crop=0&crop=1&crop=1&id=YzEWm&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h1 id="线程控制"><a href="#线程控制" class="headerlink" title="线程控制"></a>线程控制</h1><h2 id="线程属性"><a href="#线程属性" class="headerlink" title="线程属性"></a>线程属性</h2><p>可以使用pthread_attr_t结构修改线程默认属性<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806440831-d203ba64-a76a-49e4-a30f-df5fc60e4c37.png#crop=0&crop=0&crop=1&crop=1&id=z0GKI&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806441360-196a6878-2934-49eb-8778-268eee4f6959.png#crop=0&crop=0&crop=1&crop=1&id=zASKh&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806441940-91bf1d76-bb67-444d-9499-9802e0946539.png#crop=0&crop=0&crop=1&crop=1&id=qQgMJ&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806442458-32ecaf4a-8281-4a08-99b0-4b459e3ef4b1.png#crop=0&crop=0&crop=1&crop=1&id=bj3PS&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806442902-e5fd20ca-4eeb-4f3a-94e1-774baff3aa65.png#crop=0&crop=0&crop=1&crop=1&id=ZYXtM&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806443393-b028ec93-d20c-4882-b18c-faf79e5a7a0e.png#crop=0&crop=0&crop=1&crop=1&id=haLon&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806443924-998b53a3-c114-43e7-a0f2-9128723b4de6.png#crop=0&crop=0&crop=1&crop=1&id=jSaAr&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806444482-ca75eb44-cf88-489d-9573-7398d468cac9.png#crop=0&crop=0&crop=1&crop=1&id=S2zne&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="同步属性"><a href="#同步属性" class="headerlink" title="同步属性"></a>同步属性</h2><h3 id="互斥量属性pthread-mutexattr-t"><a href="#互斥量属性pthread-mutexattr-t" class="headerlink" title="互斥量属性pthread_mutexattr_t"></a>互斥量属性pthread_mutexattr_t</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806444963-02cd512a-13d5-446c-8108-e156f308596e.png#crop=0&crop=0&crop=1&crop=1&id=LIaFl&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="><br>值得注意的两个属性是进程共享属性，进程共享属性是可选的，可以通过检查系统中是否定义了_POSIX_THREAD_PROCESS_SHARED符号来判断这个平台是否支持进程共享这个属性。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806445440-e25c4fad-2835-4a09-ad29-96e049827453.png#crop=0&crop=0&crop=1&crop=1&id=lVOkl&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806445718-ca67791a-8444-4b34-95b4-e33a48753ee0.png#crop=0&crop=0&crop=1&crop=1&id=UfpNb&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806446209-20cbc238-5191-44af-883b-38d07aabbf32.png#crop=0&crop=0&crop=1&crop=1&id=RqfaC&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806446995-465703de-7546-4946-bfa1-70c514ccec9b.png#crop=0&crop=0&crop=1&crop=1&id=ZlMFh&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806447239-9a5c2c87-e213-4688-81a0-42f176264a16.png#crop=0&crop=0&crop=1&crop=1&id=TBqXX&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h3 id="读写锁属性"><a href="#读写锁属性" class="headerlink" title="读写锁属性"></a>读写锁属性</h3><p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806447652-ed2bbb33-ca1f-45f5-8cd1-03b87a0de8ab.png#crop=0&crop=0&crop=1&crop=1&id=yeh4H&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806448154-43c1884e-0c16-4013-a869-9f2d129c8e5f.png#crop=0&crop=0&crop=1&crop=1&id=uEvXw&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="重入"><a href="#重入" class="headerlink" title="重入"></a>重入</h2><p>如果一个函数在同一时刻被多个线程安全的调用，就称该函数是线程安全的。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806448860-6f8438cc-a45d-449b-8a73-a3de149fdc94.png#crop=0&crop=0&crop=1&crop=1&id=r4ghg&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806449348-bc528a0f-0b67-4272-8951-ddfed8cca6b3.png#crop=0&crop=0&crop=1&crop=1&id=u1UDF&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806449874-65a8bd57-d251-46c6-98a4-5b38eda3ca11.png#crop=0&crop=0&crop=1&crop=1&id=tl9li&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806450390-97befbff-cca2-4403-9c22-6565d9b9f78c.png#crop=0&crop=0&crop=1&crop=1&id=sxoMj&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806450778-be0f2f89-7890-4925-be79-c045b8890c81.png#crop=0&crop=0&crop=1&crop=1&id=pWvn2&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h2 id="线程私有数据"><a href="#线程私有数据" class="headerlink" title="线程私有数据"></a>线程私有数据</h2><p>线程私有数据提供了线程间组织共享的接口，因为有时候需要维护基于每个线程的数据。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806451377-84453959-aa0a-4d7d-bb18-977f4a091728.png#crop=0&crop=0&crop=1&crop=1&id=ZgHgL&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p>destructor是析构函数，当线程退出时，如果数据地址已经被设置为非null数值，那么析构函数就会被调用。<br><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806451840-cf2bb161-81d3-4f6b-8325-6d86afb951e5.png#crop=0&crop=0&crop=1&crop=1&id=U1w0E&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806452385-06839377-b648-439c-8093-b5e18714bb23.png#crop=0&crop=0&crop=1&crop=1&id=h0WiP&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<p><img src="https://cdn.nlark.com/yuque/0/2022/png/1286783/1653806452873-6ba3ee96-4d24-4ce5-b0ee-35e4c8c80b37.png#crop=0&crop=0&crop=1&crop=1&id=O3Exy&originalType=binary&ratio=1&rotation=0&showTitle=false&status=done&style=none&title="></p>
<h1 id="13-守护进程"><a href="#13-守护进程" class="headerlink" title="13.守护进程"></a>13.守护进程</h1><p>守护进程也成精灵进程，是生存期比较长的一种进程。它们常常在系统自举的时候启动，仅在系统关闭的时候终止。它们没有控制中断，一般在后台运行。<br>linux的守护进程例子有很多：1，init 进程，负责启动各运行层次特定的系统服务。</p>
<h1 id="自问自答"><a href="#自问自答" class="headerlink" title="自问自答"></a>自问自答</h1><h2 id="1，什么是可重入函数，线程安全函数，异步信号安全函数？"><a href="#1，什么是可重入函数，线程安全函数，异步信号安全函数？" class="headerlink" title="1，什么是可重入函数，线程安全函数，异步信号安全函数？"></a>1，什么是可重入函数，线程安全函数，异步信号安全函数？</h2><p>首先什么是重入?函数被不同的控制流程调用,有可能在第一次调用还没返回时就再次进入该函数,这称为重入。信号，硬件中断，线程调度等都有可能会造成重入！<br>那么在发生重入的情况下能够正常运行的函数称之为可重入函数。反之为不可重入函数。例如在进行链表的插入时，插入函数访问一个全局链表,有可能因为重入而造成错乱。可重入函数只访问自己的局部变量或参数。其实总结就是：一个可重入函数可以被多个执行流重复进入，内部使用的数据都应该来自于自身的栈空间，包括返回值也不应该是全局或者静态的，可以允许有该函数的多个副本在运行，而正是因为其中的操作数据都来自于自身的栈空间，而每次调用函数会开辟不同的栈空间，因此二者互不影响。</p>
<p>一个可重入函数需要满足的是：<br>1、不使用全局变量或静态变量；<br>2、不使用用malloc或者new开辟出的空间；<br>3、不调用不可重入函数；<br>4、不返回静态或全局数据，所有数据都有函数的调用者提供；<br>5、使用本地数据，或者通过制作全局数据的本地拷贝来保护全局数据；<br>6，不适用标准IO函数printf,scanf等（因为有用户缓冲区，而用户缓冲区有锁保护）<br>不可重入函数符合以下条件之一：<br>1、调用了malloc&#x2F;free函数，因为malloc函数是用全局链表来管理堆的。<br>2、调用了标准I&#x2F;O库函数，标准I&#x2F;O库的很多实现都以不可重入的方式使用全局数据结构。<br>3、可重入体内使用了静态的数据结构。<br>4，使用了锁（会造成死锁）<br>&#x3D;&#x3D;可重入与线程安全和异步信号安全的关系&#x3D;&#x3D;：如果一个函数对多个线程来说是可重入的，则说这个函数是线程安全的。如果函数对异步信号处理程序的重入是安全的，那么函数是异步信号安全的。</p>
<h2 id="2，什么情况下一个函数是线程安全但是对信号处理函数是不可重入的？"><a href="#2，什么情况下一个函数是线程安全但是对信号处理函数是不可重入的？" class="headerlink" title="2，什么情况下一个函数是线程安全但是对信号处理函数是不可重入的？"></a>2，什么情况下一个函数是线程安全但是对信号处理函数是不可重入的？</h2><p>假设函数func() 在执行过程中需要访问某个共享资源，因此为了实现线程安全，在使用该资源前加锁，在不需要资源解锁。那么在执行func执行到一半的时候，遇到信号并执行一个调用了func的信号处理函数，这个时候就出现了死锁。但是如果是线程在调用则不会发生这种情况</p>
<h2 id="3-什么是系统cpu时间，用户cpu时间，时钟时间？"><a href="#3-什么是系统cpu时间，用户cpu时间，时钟时间？" class="headerlink" title="3,什么是系统cpu时间，用户cpu时间，时钟时间？"></a>3,什么是系统cpu时间，用户cpu时间，时钟时间？</h2><p>进程有三种运行状态，阻塞，就绪，运行。<br>那么系统cpu时间和用户cpu时间就是系统和用户分别在运行情况下的时间。而时钟时间则是指内核从开始运行到结束整个过程所需要的时间。</p>
]]></content>
  </entry>
</search>
